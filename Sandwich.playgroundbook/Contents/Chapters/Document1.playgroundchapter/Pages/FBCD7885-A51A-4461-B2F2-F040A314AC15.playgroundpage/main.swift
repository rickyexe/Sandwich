//#-hidden-code
//
//  main.swift
//
//  Copyright © 2016-2020 Apple Inc. All rights reserved.
//
//#-code-completion(everything, hide)
//#-code-completion(keyword, show, for, func, if, let, var, while, in)
//#-code-completion(literal, show, literal, array, boolean, color, dictionary, image, string, integer, nil)
//#-code-completion(snippet, show, repeat, switch, protocol, enum, struct, class, return)
//#-code-completion(currentmodule, show)
//#-code-completion(module, show, MyFiles, SpriteKit, Swift, UIKit)
//#-code-completion(identifier, show, (hue:saturation:brightness:alpha:), (image:), (image:columns:rows:), (image:columns:rows:isDynamic:name:), (image:name:), (red:green:blue:alpha:), (text:color:), (text:color:font:size:name:), (type:), (type:text:name:), (width:height:), (x:y:), AcademyEngravedLET, AmericanTypewriter, AppleSDGothicNeo, Arial, ArialRoundedMTBold, Avenir, AvenirNext, AvenirNextCondensed, Baskerville, Bodoni72, Bounce1, Bounce2, Bounce3, BradleyHand, Button, ButtonType, ChalkDuster, ChalkboardSE, Cochin, Color, Copperplate, Courier, CourierNew, Didot, Font, Futura, Georgia, GillSans, Graphic, Helvetica, HelveticaNeue, HiraginoMinchoProN, HiraginoSans, Impact, Joint, Label, MarkerFelt, Menlo, Noteworthy, Optima, Palatino, Papyrus, PartyLET, PingFangSC, PingFangTC, Point, SavoyeLET, Scene, Size, SnellRoundhand, Sprite, String, Superclarendon, SystemBoldItalic, SystemFontBlack, SystemFontBold, SystemFontHeavy, SystemFontLight, SystemFontMedium, SystemFontRegular, SystemFontSemibold, SystemFontThin, SystemFontUltraLight, SystemHeavyItalic, SystemItalic, Thonburi, TimesNewRoman, Touch, TrebuchetMS, Verdana, Zapfino, add(joint:), allowsRotation, allowsTouchInteraction, alpha, angle, angularDamping, angularVelocity, applyForce(x:y:duration:), applyImpulse(x:y:), arabic, area, aspectFitMaximum, aspectFitMinimum, audioPlayAction(fileNamed:), backgroundColor, backgroundColors, backgroundImage, beam, beep, blip, boing1, boing2, boing3, boop1, boop2, boop3, bottom, bounciness, buttonPress1, buttonType, capturesTouches, center, chinese, chineseHongKong, chineseTaiwan, circle(radius:color:), circle(radius:color:colors:), circlePoints(radius:count:), clang, clear(), clunk, collisionNotificationCategories, constrained, containing:, contentPresentation, crash, crystal, customShape(path:color:), customShape(path:color:colors:), czech, danish, defeat1, density, distance(from:), drag, drop, dutch, echobird, electricBeep1, electricBeep2, electricBeep3, electricBeep4, electricBeepFader, englishAustralia, englishIreland, englishSouthAfrica, englishUK, englishUS, explosionShort, fadeAlpha(by:duration:), fadeAlpha(to:duration:), fadeIn(after:), fadeOut(after:), finnish, firstTouch, fit(within:), fixed(from:to:at:), font, fontSize, force, frenchCanada, frenchFrance, friction, friendlyPassage, german, getGraphics(at:in:), getGraphics(named:), getGraphicsWithName(containing:), graphics, greek, green, gridPoints(size:count:angle:), hasCollisionBorder, hebrew, height, helicopterWhoosh, hindi, horizontalGravity, hue:saturation:brightness:alpha:, hungarian, image, image(text:), image:, image:columns:rows:, image:columns:rows:isDynamic:name:, image:name:, indonesian, interactionCategory, isAffectedByGravity, isDynamic, isGridVisible, isResting, italian, japanese, joints, korean, laser1, laser2, laser3, left, limit(from:at:to:at:), line(length:thickness:color:), line(length:thickness:color:colors:), line(start:end:thickness:color:), line(start:end:thickness:color:colors:), linearDamping, location, machineGreeting1, machineGreeting2, machineGreeting3, mass, miss, move(to:duration:), moveBy(x:y:duration:), name, node, norwegian, onCollisionHandler, onGraphicTouchedHandler, onTouchMovedHandler, orbit(x:y:period:), orbitAction(x:y:period:), overlaid(with:offsetBy:), physicsBody, pi, pin(from:to:around:), pinned, place(_:), place(_:at:), place(_:at:anchoredTo:), place(at:), playSound(_:volume:), pleasantDing1, pleasantDing2, pleasantDing3, polish, polygon(radius:sides:color:), polygon(radius:sides:color:colors:), pop, pop1, pop2, portugueseBrazil, portuguesePortugal, position, powerUp1, powerUp2, powerUp3, powerUp4, powerup, pulsate(), pulsate(period:count:), puzzleJam, radiant, randomCharacter, randomIndex, randomItem, rectangle(width:height:cornerRadius:color:), rectangle(width:height:cornerRadius:color:colors:), red, red:green:blue:alpha:, remove(), remove(_:), remove(joint:), removeAction(forKey:), removeAllActions(), removeGraphics(named:), removeHandler(forInteraction:), removeJoints(named:), restituion, retroBass, retroCollide1, retroCollide2, retroCollide3, retroCollide4, retroCollide5, retroJump1, retroJump2, retroPowerUp1, retroPowerUp2, retroTwang1, retroTwang2, right, romanian, rotate(byAngle:duration:), rotate(toAngle:duration:), rotation, rotationalDrag, run(_:), run(_:key:), runAnimation(_:timePerFrame:numberOfTimes:), russian, scale, scale(by:duration:), scale(to:duration:), scaleX(by:y:duration:), scaleX(to:y:duration:), scaledImage(size:), setHandler(for:handler:), setOnCollisionHandler(_:), setOnTouchHandler(_:), setOnTouchMovedHandler(_:), setTintColor(_:blend:), setVelocity(x:y:), shake(duration:), shuffle(), shuffled(), size, sliding(from:to:at:axis:), slovak, somethingBad1, somethingBad2, somethingBad3, somethingBad4, somethingGood1, somethingGood2, somethingGood3, somethingGood4, somethingGood5, somethingGood6, somethingGood7, sonar, spanishMexico, spanishSpain, speak(text:), speak(text:withAccent:rate:pitch:completion:), spin(period:), splat, spring(from:at:to:at:), spring1, spring2, spring3, spring4, spriteA, spriteB, squarePoints(width:count:), squeak, star(radius:points:sharpness:color:), star(radius:points:sharpness:color:colors:), strangeWobble, strokeColor, strokeWidth, swedish, text, text:, text:color:, text:color:font:size:name:, textColor, thai, thud, tick, top, touch, touchCancelled, touchHandler, touchUp, tubeHit1, tubeHit2, tubeHit3, turkish, type:, type:text:name:, velocity, verticalGravity, victory1, victory2, victory3, victory4, wall, warble, warp, width, width:height:, x, x:y:, x:y:duration:, xScale, y, yScale, zap)
//#-code-completion(description, hide, "(hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat)", "(x: CGFloat, y: CGFloat)", "(x: Float, y: Float)", "(width: CGFloat, height: CGFloat)", "(width: Float, height: Float)", "(point: CGPoint)", "(from: Decoder) throws", "(music: Music, volume: Int)", "playMusic(music: Music, volume: Int)", "(sound: Sound, volume: Int)", "playSound(sound: Sound, volume: Int)", "from(playgroundValue: PlaygroundValue)", "(sound: Sound)", "(sound: Sound, loopFireHandler: (() -> Void)?)")
//#-end-hidden-code
/*:
 ### Sandwich Generation and Investment
 Sandwich generation refers to someone who needs to finance their parents, theirself, and also their kids. Of course it won’t be a problem if this person is capable or established enough to do it. But the problem come when it is even hard to pay for their own living. This will cause some problem like a lot of conflict because of economy condition, abandoned child education and so on. This sandwich generation status usually will be passed down to their kids and this will continue until some generation made a big change to their economy condition.

 Maybe you’re a sandwich generation right now or maybe you’re not. Either way, there’s a way to cut this endless cycle or to prevent this to happen, which is to have passive income that can pay for your daily life expenses at old age even if you didn’t work. To get this passive income you need to put a large sum of money to an investment instrument that can give you a return rate that is enough for your daily life cost. Now the question arise, how to get this large sum of money. One of the way is to invest in an instrument until you achieve your target and fortunately there’s also a theory called Compound Interest.

 Albert Einstein, said “Compound interest is the eighth wonder of the world. He who understands it earns it, he who doesn’t,  pays it.”  . But what does it really mean? Compound interest is the interest on a investment calculated based on both the initial principal and the accumulated interest from previous periods (investopedia.com) . Basically you just need to invest and don't take the return at all so that your investment will get bigger and bigger like a snowball.
 Still haven’t grasp the concept yet ? Run the code to see the simulation
 */

// investment time
var totalMonth = 12

// daily monthly contribution
// money you want to invest / save per month
var dailyContribution : Double = 1200

// estimated yearly interest rate (in percent)
// interest rate will fluctuate in real life
var interestRateYearly : Double = 30

/*:
 Now you've seen the difference, let's go to [Time Comparisson](@next)!
*/



//#-hidden-code
import Foundation
import UIKit
setUpLiveView(presentation: .aspectFitMinimum)


scene.setBorderPhysics(hasCollisionBorder: true)
scene.verticalGravity = -12
setupScene(month : totalMonth, income : dailyContribution, interestrate : interestRateYearly)
    
    
    
    func setupScene(month : Int, income: Double, interestrate : Double) {
        
        var year            = 0
        var year2           = 0
        var time1  : Double = 0.8
        var time2  : Double = 0.8 
        var score1 : Double = 0
        var score1no : Double = 0
        var score2 : Double = 0
        var size : Double = 0
        
        let spriteCannon = Graphic(image: "".image())
        spriteCannon.scale = 1.5
        spriteCannon.rotation = 180
        scene.place(spriteCannon, at: Point(x: 270, y: 430 ))
        
        let spriteCannon2 = Graphic(image: "".image())
        spriteCannon2.scale = 1.5
        spriteCannon2.rotation = 180
        scene.place(spriteCannon2, at: Point(x: -270, y: 430))
        
        let platform = Sprite.rectangle(width: 1200, height: 25, cornerRadius: 10, color: #colorLiteral(red: 0.3248277307, green: 0.8369095325, blue: 0.9915711284, alpha: 1.0), colors: [#colorLiteral(red: 0.336129725, green: 0.06358888, blue: 0.1618391573, alpha: 1.0), #colorLiteral(red: 0.336129725, green: 0.06358888, blue: 0.1618391573, alpha: 1.0)])
        platform.rotation = 90
        platform.physicsBody?.mass = 100000
        platform.physicsBody?.friction = 0.50
        scene.place(platform, at: Point(x: -5, y: -250))
        
        let yearLabel1 =  Label(text: String(year), color: #colorLiteral(red: 0.5764705882352941, green: 0.5764705882352941, blue: 0.5764705882352941, alpha: 1.0))
        scene.place(yearLabel1, at: Point(x: -370, y: 450))
        
        let yearLabel2 =  Label(text: String(year), color: #colorLiteral(red: 0.5764705882352941, green: 0.5764705882352941, blue: 0.5764705882352941, alpha: 1.0))
        scene.place(yearLabel2, at: Point(x: 380, y: 450))
        
        let labelWithout = Label(text: "No Investment", color: #colorLiteral(red: 0.5764705882352941, green: 0.5764705882352941, blue: 0.5764705882352941, alpha: 1.0))
        scene.place(labelWithout, at: Point(x: -250, y: 400))
        
        let labelWith =  Label(text: "Investment + Compound Interest", color: #colorLiteral(red: 0.5764705882352941, green: 0.5764705882352941, blue: 0.5764705882352941, alpha: 1.0))
        scene.place(labelWith, at: Point(x: 250, y: 400))
        
        let labelScore1 = Label(text: "0", color: #colorLiteral(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0))
        scene.place(labelScore1, at: Point(x: -100, y: 450))
        
        let labelScore2 = Label(text: "0", color: #colorLiteral(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0))
        scene.place(labelScore2, at: Point(x: 100, y: 450))
        
        
        //without compound interest
        Timer.scheduledTimer(withTimeInterval: time1, repeats: true) { (timer) in
            
            year = year + 1
            score1 = score1 + Double(income)
            labelScore1.text = "$" + String(format: "%.2f", score1)
            spriteCannon2.pulse()
            generateRandomSpriteShape(at: spriteCannon2.location ,size: 15)
            
            yearLabel1.text = String(year/12) + " Years " + String(year % 12) + " Months "
            
            if year == month  {
                timer.invalidate()
            }
            
            
        }
        
        //with compound interest
        Timer.scheduledTimer(withTimeInterval: time2, repeats: true) { (timer) in
            playSound(ShapesSound.pop1)
            year2 = year2 + 1
            if(year2 == 1)
            {
                score2 = score2 + income
                size = 15
            }else{
                size =  ((interestrate/12) * score2 / 100)  / income
                score2 = score2 + income + ((interestrate/12) * score2 / 100 )
                
                size = size * 15 + 15
            }
            
            labelScore2.text = "$" + String(format: "%.2f", score2)
            spriteCannon.pulse()
            generateRandomSpriteShape(at: spriteCannon.location, size: Int(size)) 
            yearLabel2.text = String(year2/12) + " Years " + String(year2 % 12) + " Months "
            if year2 == month {
                timer.invalidate() 
            }
        }
    }
    
    
    
    /// Creates a random sprite shape.
    func generateRandomSpriteShape(at point: Point, size : Int) {
        var sprite: Sprite
        sprite = Sprite.rectangle(width: 450, height: size, cornerRadius: 0, color: Color.random())
        sprite.isAffectedByGravity = true
        sprite.allowsRotation = true
        sprite.isDraggable = true
        sprite.physicsBody?.mass = 1000
        
        sprite.physicsBody?.friction = 100
        
        scene.place(sprite, at: point)
        
        
    }
//#-end-hidden-code

    
    



