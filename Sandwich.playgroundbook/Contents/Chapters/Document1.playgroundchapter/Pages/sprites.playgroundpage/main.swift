//#-hidden-code
//
//  main.swift
//
//  Copyright Â© 2016-2020 Apple Inc. All rights reserved.
//
//#-code-completion(everything, hide)
//#-code-completion(keyword, show, for, func, if, let, var, while, in)
//#-code-completion(literal, show, literal, array, boolean, color, dictionary, image, string, integer, nil)
//#-code-completion(snippet, show, repeat, switch, protocol, enum, struct, class, return)
//#-code-completion(currentmodule, show)
//#-code-completion(module, show, MyFiles, SpriteKit, Swift, UIKit)
//#-code-completion(identifier, show, (hue:saturation:brightness:alpha:), (image:), (image:columns:rows:), (image:columns:rows:isDynamic:name:), (image:name:), (red:green:blue:alpha:), (text:color:), (text:color:font:size:name:), (type:), (type:text:name:), (width:height:), (x:y:), AcademyEngravedLET, AmericanTypewriter, AppleSDGothicNeo, Arial, ArialRoundedMTBold, Avenir, AvenirNext, AvenirNextCondensed, Baskerville, Bodoni72, Bounce1, Bounce2, Bounce3, BradleyHand, Button, ButtonType, ChalkDuster, ChalkboardSE, Cochin, Color, Copperplate, Courier, CourierNew, Didot, Font, Futura, Georgia, GillSans, Graphic, Helvetica, HelveticaNeue, HiraginoMinchoProN, HiraginoSans, Impact, Joint, Label, MarkerFelt, Menlo, Noteworthy, Optima, Palatino, Papyrus, PartyLET, PingFangSC, PingFangTC, Point, SavoyeLET, Scene, Size, SnellRoundhand, Sprite, String, Superclarendon, SystemBoldItalic, SystemFontBlack, SystemFontBold, SystemFontHeavy, SystemFontLight, SystemFontMedium, SystemFontRegular, SystemFontSemibold, SystemFontThin, SystemFontUltraLight, SystemHeavyItalic, SystemItalic, Thonburi, TimesNewRoman, Touch, TrebuchetMS, Verdana, Zapfino, add(joint:), allowsRotation, allowsTouchInteraction, alpha, angle, angularDamping, angularVelocity, applyForce(x:y:duration:), applyImpulse(x:y:), arabic, area, aspectFitMaximum, aspectFitMinimum, audioPlayAction(fileNamed:), backgroundColor, backgroundColors, backgroundImage, beam, beep, blip, boing1, boing2, boing3, boop1, boop2, boop3, bottom, bounciness, buttonPress1, buttonType, capturesTouches, center, chinese, chineseHongKong, chineseTaiwan, circle(radius:color:), circle(radius:color:colors:), circlePoints(radius:count:), clang, clear(), clunk, collisionNotificationCategories, constrained, containing:, contentPresentation, crash, crystal, customShape(path:color:), customShape(path:color:colors:), czech, danish, defeat1, density, distance(from:), drag, drop, dutch, echobird, electricBeep1, electricBeep2, electricBeep3, electricBeep4, electricBeepFader, englishAustralia, englishIreland, englishSouthAfrica, englishUK, englishUS, explosionShort, fadeAlpha(by:duration:), fadeAlpha(to:duration:), fadeIn(after:), fadeOut(after:), finnish, firstTouch, fit(within:), fixed(from:to:at:), font, fontSize, force, frenchCanada, frenchFrance, friction, friendlyPassage, german, getGraphics(at:in:), getGraphics(named:), getGraphicsWithName(containing:), graphics, greek, green, gridPoints(size:count:angle:), hasCollisionBorder, hebrew, height, helicopterWhoosh, hindi, horizontalGravity, hue:saturation:brightness:alpha:, hungarian, image, image(text:), image:, image:columns:rows:, image:columns:rows:isDynamic:name:, image:name:, indonesian, interactionCategory, isAffectedByGravity, isDynamic, isGridVisible, isResting, italian, japanese, joints, korean, laser1, laser2, laser3, left, limit(from:at:to:at:), line(length:thickness:color:), line(length:thickness:color:colors:), line(start:end:thickness:color:), line(start:end:thickness:color:colors:), linearDamping, location, machineGreeting1, machineGreeting2, machineGreeting3, mass, miss, move(to:duration:), moveBy(x:y:duration:), name, node, norwegian, onCollisionHandler, onGraphicTouchedHandler, onTouchMovedHandler, orbit(x:y:period:), orbitAction(x:y:period:), overlaid(with:offsetBy:), physicsBody, pi, pin(from:to:around:), pinned, place(_:), place(_:at:), place(_:at:anchoredTo:), place(at:), playSound(_:volume:), pleasantDing1, pleasantDing2, pleasantDing3, polish, polygon(radius:sides:color:), polygon(radius:sides:color:colors:), pop, pop1, pop2, portugueseBrazil, portuguesePortugal, position, powerUp1, powerUp2, powerUp3, powerUp4, powerup, pulsate(), pulsate(period:count:), puzzleJam, radiant, randomCharacter, randomIndex, randomItem, rectangle(width:height:cornerRadius:color:), rectangle(width:height:cornerRadius:color:colors:), red, red:green:blue:alpha:, remove(), remove(_:), remove(joint:), removeAction(forKey:), removeAllActions(), removeGraphics(named:), removeHandler(forInteraction:), removeJoints(named:), restituion, retroBass, retroCollide1, retroCollide2, retroCollide3, retroCollide4, retroCollide5, retroJump1, retroJump2, retroPowerUp1, retroPowerUp2, retroTwang1, retroTwang2, right, romanian, rotate(byAngle:duration:), rotate(toAngle:duration:), rotation, rotationalDrag, run(_:), run(_:key:), runAnimation(_:timePerFrame:numberOfTimes:), russian, scale, scale(by:duration:), scale(to:duration:), scaleX(by:y:duration:), scaleX(to:y:duration:), scaledImage(size:), setHandler(for:handler:), setOnCollisionHandler(_:), setOnTouchHandler(_:), setOnTouchMovedHandler(_:), setTintColor(_:blend:), setVelocity(x:y:), shake(duration:), shuffle(), shuffled(), size, sliding(from:to:at:axis:), slovak, somethingBad1, somethingBad2, somethingBad3, somethingBad4, somethingGood1, somethingGood2, somethingGood3, somethingGood4, somethingGood5, somethingGood6, somethingGood7, sonar, spanishMexico, spanishSpain, speak(text:), speak(text:withAccent:rate:pitch:completion:), spin(period:), splat, spring(from:at:to:at:), spring1, spring2, spring3, spring4, spriteA, spriteB, squarePoints(width:count:), squeak, star(radius:points:sharpness:color:), star(radius:points:sharpness:color:colors:), strangeWobble, strokeColor, strokeWidth, swedish, text, text:, text:color:, text:color:font:size:name:, textColor, thai, thud, tick, top, touch, touchCancelled, touchHandler, touchUp, tubeHit1, tubeHit2, tubeHit3, turkish, type:, type:text:name:, velocity, verticalGravity, victory1, victory2, victory3, victory4, wall, warble, warp, width, width:height:, x, x:y:, x:y:duration:, xScale, y, yScale, zap)
//#-code-completion(description, hide, "(hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat)", "(x: CGFloat, y: CGFloat)", "(x: Float, y: Float)", "(width: CGFloat, height: CGFloat)", "(width: Float, height: Float)", "(point: CGPoint)", "(from: Decoder) throws", "(music: Music, volume: Int)", "playMusic(music: Music, volume: Int)", "(sound: Sound, volume: Int)", "playSound(sound: Sound, volume: Int)", "from(playgroundValue: PlaygroundValue)", "(sound: Sound)", "(so und: Sound, loopFireHandler: (() -> Void)?)")
//#-end-hidden-code
/*:
 ### Time Comparisson
 I hope now you understand a bit about sandwich generation, investment, and compound interest . Letâ€™s see this with another perspective. Run the code and you will see time comparisson to achieve a target, between someone that save their money without any investment and someone that invest. Each ball represent a month of your life contributing to achieve your target.
 */

// investment goals
var targetInvestment : Double = 100000
// daily monthly contribution
var monthlyContribution : Double = 300

// estimated interest rate (in percent)
// interest rate will fluctuate in real life
var interestRateYearly : Double = 7

// time interval of the ball
var timerInterval: Double = 0.03

//disclaimer : When the timer slow down or stop before the target reached , you need to press run my code again. From my research it's because of app nap but i haven't found how to turn it off in a playgroundbook project.

/*:
 Let's go to [Final Page](@next)!
*/



//#-hidden-code
setUpLiveView(presentation: .aspectFitMinimum)
import Foundation
import UIKit


scene.setBorderPhysics(hasCollisionBorder: true)
scene.verticalGravity = -12
setupScene(target: targetInvestment, income: monthlyContribution, interestrate: interestRateYearly, timerInterval : timerInterval)
    
    
    
    func setupScene(target : Double, income: Double, interestrate: Double, timerInterval : Double) {
        
        var year            = 0
        var year2           = 0
        var time1  : Double = timerInterval
        var score1 : Double = 0
        var score2 : Double = 0
        
        let spriteCannon = Graphic(image: "ðŸ•³".image())
        spriteCannon.scale = 1.5
        spriteCannon.rotation = 90
        scene.place(spriteCannon, at: Point(x: 430, y: 270))
        
        let spriteCannon2 = Graphic(image: "ðŸ•³".image())
        spriteCannon2.scale = 1.5
        spriteCannon2.rotation = 270
        scene.place(spriteCannon2, at: Point(x: -430, y: 270))
        
        let platform = Sprite.rectangle(width: 1200, height: 25, cornerRadius: 10, color: #colorLiteral(red: 0.3248277307, green: 0.8369095325, blue: 0.9915711284, alpha: 1.0), colors: [#colorLiteral(red: 0.336129725, green: 0.06358888, blue: 0.1618391573, alpha: 1.0), #colorLiteral(red: 0.336129725, green: 0.06358888, blue: 0.1618391573, alpha: 1.0)])
        platform.rotation = 90
        platform.physicsBody?.mass = 100000
        platform.physicsBody?.friction = 0.50
        scene.place(platform, at: Point(x: -5, y: -250))
        
        let yearLabel1 =  Label(text: String(year), color: #colorLiteral(red: 0.5764705882352941, green: 0.5764705882352941, blue: 0.5764705882352941, alpha: 1.0))
        scene.place(yearLabel1, at: Point(x: -370, y: 450))
        
        let yearLabel2 =  Label(text: String(year), color: #colorLiteral(red: 0.5764705882352941, green: 0.5764705882352941, blue: 0.5764705882352941, alpha: 1.0))
        scene.place(yearLabel2, at: Point(x: 380, y: 450))
        
        let labelWithout = Label(text: "No Investment", color: #colorLiteral(red: 0.5764705882352941, green: 0.5764705882352941, blue: 0.5764705882352941, alpha: 1.0))
        scene.place(labelWithout, at: Point(x: -250, y: 400))
        
        let labelWith =  Label(text: "Investment + Compound Interest", color: #colorLiteral(red: 0.5764705882352941, green: 0.5764705882352941, blue: 0.5764705882352941, alpha: 1.0))
        scene.place(labelWith, at: Point(x: 250, y: 400))
        
        let labelScore1 = Label(text: "0", color: #colorLiteral(red: 0.5764705882352941, green: 0.5764705882352941, blue: 0.5764705882352941, alpha: 1.0))
        scene.place(labelScore1, at: Point(x: -100, y: 450))
        
        let labelScore2 = Label(text: "0", color: #colorLiteral(red: 0.5764705882352941, green: 0.5764705882352941, blue: 0.5764705882352941, alpha: 1.0))
        scene.place(labelScore2, at: Point(x: 100, y: 450))
        
        
        //without compound interest
        let timer = Timer.scheduledTimer(withTimeInterval: time1, repeats: true ) {(timer) in
            
            year = year + 1
            score1 = score1 + income 
            labelScore1.text = "$" +  String(format: "%.2f", score1)
            generateRandomSpriteShape(at: spriteCannon2.location, type: 2)
            yearLabel1.text = String(year/12) + " Years " + String(year % 12) + " Months "
            
            
            if score2 <= target {
                year2 = year2 + 1
                if(year2 > 1)
                {
                    score2 = score2 + income + ((interestrate/12) * score2 / 100 )
                }else{
                    score2 = score2 + income
                }
                
                labelScore2.text = "$" + String(format: "%.2f", score2)
                generateRandomSpriteShape(at: spriteCannon.location, type: 1)
                yearLabel2.text = String(year2/12) + " Years " + String(year2 % 12) + " Months "
            }
            
            
            if score1 >= target  {
                timer.invalidate()
            }
        }
        RunLoop.current.add(timer, forMode: .common)
    }
    
    
    /// Creates a random sprite shape.
    func generateRandomSpriteShape(at point: Point, type : Int) {
        var sprite: Sprite
        sprite = Sprite.circle(radius: 18, color: Color.random())
        sprite.isAffectedByGravity = true
        sprite.allowsRotation = true
        sprite.isDraggable = true
        
        sprite.physicsBody?.friction = 1
        
        scene.place(sprite, at: point)
        if type == 1 {
            sprite.applyImpulse(x: -100, y: 70)
        }else{
            sprite.applyImpulse(x: 100, y: 70)
        }
        
        
    }
//#-end-hidden-code
    





